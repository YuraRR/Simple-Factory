var t={dragStart:!0},e=(e,l={})=>{let c,u,{bounds:g,axis:f="both",gpuAcceleration:h=!0,legacyTranslate:p=!0,transform:m,applyUserSelectHack:y=!0,disabled:b=!1,ignoreMultitouch:w=!1,recomputeBounds:v=t,grid:x,position:E,cancel:S,handle:A,defaultClass:C="neodrag",defaultClassDragging:N="neodrag-dragging",defaultClassDragged:_="neodrag-dragged",defaultPosition:D={x:0,y:0},onDragStart:M,onDrag:B,onDragEnd:$}=l,R=!1,I=0,H=0,L=0,P=0,T=0,X=0,{x:Y,y:q}=E?{x:E?.x??0,y:E?.y??0}:D;K(Y,q);let j,k,O,U,W,z="",F=!!E;v={...t,...v};const G=document.body.style,J=e.classList;function K(t=I,n=H){if(!m){if(p){let r=`${+t}px, ${+n}px`;return s(e,"transform",h?`translate3d(${r}, 0)`:`translate(${r})`)}return s(e,"translate",`${+t}px ${+n}px ${h?"1px":""}`)}const o=m({offsetX:t,offsetY:n,rootNode:e});r(o)&&s(e,"transform",o)}const Q=(t,n)=>{const r={offsetX:I,offsetY:H,rootNode:e,currentNode:W};e.dispatchEvent(new CustomEvent(t,{detail:r})),n?.(r)};const V=addEventListener;V("pointerdown",tt,!1),V("pointerup",et,!1),V("pointermove",nt,!1),s(e,"touch-action","none");const Z=()=>{let t=e.offsetWidth/k.width;return isNaN(t)&&(t=1),t};function tt(t){if(b)return;if(2===t.button)return;if(w&&!t.isPrimary)return;if(v.dragStart&&(j=a(g,e)),r(A)&&r(S)&&A===S)throw new Error("`handle` selector can't be same as `cancel` selector");if(J.add(C),O=function(t,e){if(!t)return[e];if(d(t))return[t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");return Array.from(n.values())}(A,e),U=function(t,e){if(!t)return[];if(d(t))return[t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");return Array.from(n.values())}(S,e),c=/(both|x)/.test(f),u=/(both|y)/.test(f),i(U,O))throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");const n=t.composedPath()[0];if(!O.some((t=>t.contains(n)||t.shadowRoot?.contains(n)))||i(U,[n]))return;W=1===O.length?e:O.find((t=>t.contains(n))),R=!0,k=e.getBoundingClientRect(),y&&(z=G.userSelect,G.userSelect="none"),Q("neodrag:start",M);const{clientX:o,clientY:s}=t,l=Z();c&&(L=o-Y/l),u&&(P=s-q/l),j&&(T=o-k.left,X=s-k.top)}function et(){R&&(v.dragEnd&&(j=a(g,e)),J.remove(N),J.add(_),y&&(G.userSelect=z),Q("neodrag:end",$),c&&(L=I),u&&(P=H),R=!1)}function nt(t){if(!R)return;v.drag&&(j=a(g,e)),J.add(N),t.preventDefault(),k=e.getBoundingClientRect();let r=t.clientX,i=t.clientY;const s=Z();if(j){const t={left:j.left+T,top:j.top+X,right:j.right+T-k.width,bottom:j.bottom+X-k.height};r=n(r,t.left,t.right),i=n(i,t.top,t.bottom)}if(Array.isArray(x)){let[t,e]=x;if(isNaN(+t)||t<0)throw new Error("1st argument of `grid` must be a valid positive number");if(isNaN(+e)||e<0)throw new Error("2nd argument of `grid` must be a valid positive number");let n=r-L,a=i-P;[n,a]=o([t/s,e/s],n,a),r=L+n,i=P+a}c&&(I=Math.round((r-L)*s)),u&&(H=Math.round((i-P)*s)),Y=I,q=H,Q("neodrag",B),K()}return{destroy:()=>{const t=removeEventListener;t("pointerdown",tt,!1),t("pointerup",et,!1),t("pointermove",nt,!1)},update:e=>{f=e.axis||"both",b=e.disabled??!1,w=e.ignoreMultitouch??!1,A=e.handle,g=e.bounds,v=e.recomputeBounds??t,S=e.cancel,y=e.applyUserSelectHack??!0,x=e.grid,h=e.gpuAcceleration??!0,p=e.legacyTranslate??!0,m=e.transform;const n=J.contains(_);J.remove(C,_),C=e.defaultClass??"neodrag",N=e.defaultClassDragging??"neodrag-dragging",_=e.defaultClassDragged??"neodrag-dragged",J.add(C),n&&J.add(_),F&&(Y=I=e.position?.x??I,q=H=e.position?.y??H,K())}}},n=(t,e,n)=>Math.min(Math.max(t,e),n),r=t=>"string"==typeof t,o=([t,e],n,r)=>{const o=(t,e)=>0===e?0:Math.ceil(t/e)*e;return[o(n,t),o(r,e)]};var i=(t,e)=>t.some((t=>e.some((e=>t.contains(e)))));function a(t,e){if(void 0===t)return;if(d(t))return t.getBoundingClientRect();if("object"==typeof t){const{top:e=0,left:n=0,right:r=0,bottom:o=0}=t;return{top:e,right:window.innerWidth-r,bottom:window.innerHeight-o,left:n}}if("parent"===t)return e.parentNode.getBoundingClientRect();const n=document.querySelector(t);if(null===n)throw new Error("The selector provided for bound doesn't exists in the document.");return n.getBoundingClientRect()}var s=(t,e,n)=>t.style.setProperty(e,n),d=t=>t instanceof HTMLElement,l=class{constructor(t,n={}){this.node=t,this._dragInstance=e(t,this._options=n)}_dragInstance;_options={};updateOptions(t){this._dragInstance.update(Object.assign(this._options,t))}set options(t){this._dragInstance.update(this._options=t)}get options(){return this._options}destroy(){this._dragInstance.destroy()}};export{l as Draggable};