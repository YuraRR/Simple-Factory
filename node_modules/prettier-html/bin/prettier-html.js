#!/usr/bin/env node

const fs = require("fs");
const getStdin = require("get-stdin");
const minimist = require("minimist");
const prettierHtml = require("../src/index.js");
const glob = require("glob");

const argv = minimist(process.argv.slice(2), {
  boolean: ["stdin", "help"],
  unknown: param => {
    if (param.startsWith("-")) {
      console.warn("Ignored unknown option: " + param + "\n");
      return false;
    }
  }
});

const filepatterns = argv["_"];
const write = argv["write"];
const stdin = argv["stdin"] || (!filepatterns.length && !process.stdin.isTTY);

if (argv["help"] || (!filepatterns.length && !stdin)) {
  console.log(
    "Usage: prettier-html [opts] [filename ...]\n\n" +
      "Available options:\n" +
      "  --stdin                  Read input from stdin.\n"
  );
  process.exit(argv["help"] ? 0 : 1);
}

if (stdin) {
  getStdin().then(input => {
    try {
      // Don't use `console.log` here since it adds an extra newline at the end.
      process.stdout.write(prettierHtml(input));
    } catch (e) {
      handleError("stdin", e);
      return;
    }
  });
}

eachFilename(filepatterns, filename => {
  let input;
  try {
    input = fs.readFileSync(filename, "utf8");
  } catch (e) {
    // Add newline to split errors from filename line.
    process.stdout.write("\n");

    console.error("Unable to read file: " + filename + "\n" + err);
    // Don't exit the process if one file failed
    process.exitCode = 2;
    console.error(e);
    return;
  }

  const start = Date.now();

  try {
    const output = prettierHtml(input);
    process.stdout.write(output);
  } catch (e) {
    // Add newline to split errors from filename line.
    process.stdout.write("\n");
    console.error(e);
    return;
  }
});

function eachFilename(patterns, callback) {
  patterns.forEach(pattern => {
    glob(pattern, (err, filenames) => {
      if (err) {
        console.error("Unable to expand glob pattern: " + pattern + "\n" + err);
        // Don't exit the process if one pattern failed
        process.exitCode = 2;
        return;
      }

      filenames.forEach(filename => {
        callback(filename);
      });
    });
  });
}
